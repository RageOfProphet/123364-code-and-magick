{"version":3,"sources":["webpack:///webpack/bootstrap 325500b88e1be4bf9b11?bcba*","webpack:///./src/js/game.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA,aAAY;AACZ;AACA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA,iBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAqB,aAAa;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,gBAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAqB,iBAAiB;AACtC;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAO;;AAEP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA,sBAAqB,OAAO;AAC5B,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gBAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,EAAC","file":"js/game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 325500b88e1be4bf9b11\n **/","'use strict';\n\nwindow.Game = (function() {\n  /**\n   * @const\n   * @type {number}\n   */\n  var HEIGHT = 300;\n\n  /**\n   * @const\n   * @type {number}\n   */\n  var WIDTH = 700;\n\n  /**\n   * ID уровней.\n   * @enum {number}\n   */\n  var Level = {\n    INTRO: 0,\n    MOVE_LEFT: 1,\n    MOVE_RIGHT: 2,\n    LEVITATE: 3,\n    HIT_THE_MARK: 4\n  };\n\n  /**\n   * Порядок прохождения уровней.\n   * @type {Array.<Level>}\n   */\n  var LevelSequence = [\n    Level.INTRO\n  ];\n\n  /**\n   * Начальный уровень.\n   * @type {Level}\n   */\n  var INITIAL_LEVEL = LevelSequence[0];\n\n  /**\n   * Допустимые виды объектов на карте.\n   * @enum {number}\n   */\n  var ObjectType = {\n    ME: 0,\n    FIREBALL: 1\n  };\n\n  /**\n   * Допустимые состояния объектов.\n   * @enum {number}\n   */\n  var ObjectState = {\n    OK: 0,\n    DISPOSED: 1\n  };\n\n  /**\n   * Коды направлений.\n   * @enum {number}\n   */\n  var Direction = {\n    NULL: 0,\n    LEFT: 1,\n    RIGHT: 2,\n    UP: 4,\n    DOWN: 8\n  };\n\n  /**\n   * Карта спрайтов игры.\n   * @type {Object.<ObjectType, Object>}\n   */\n  var SpriteMap = {};\n  var REVERSED = '-reversed';\n\n  SpriteMap[ObjectType.ME] = {\n    width: 61,\n    height: 84,\n    url: 'img/wizard.gif'\n  };\n\n  //TODO: Find a clever way\n  SpriteMap[ObjectType.ME + REVERSED] = {\n    width: 61,\n    height: 84,\n    url: 'img/wizard-reversed.gif'\n  };\n\n  SpriteMap[ObjectType.FIREBALL] = {\n    width: 24,\n    height: 24,\n    url: 'img/fireball.gif'\n  };\n\n  /**\n   * Правила перерисовки объектов в зависимости от состояния игры.\n   * @type {Object.<ObjectType, function(Object, Object, number): Object>}\n   */\n  var ObjectsBehaviour = {};\n\n  /**\n   * Обновление движения мага. Движение мага зависит от нажатых в данный момент\n   * стрелок. Маг может двигаться одновременно по горизонтали и по вертикали.\n   * На движение мага влияет его пересечение с препятствиями.\n   * @param {Object} object\n   * @param {Object} state\n   * @param {number} timeframe\n   */\n  ObjectsBehaviour[ObjectType.ME] = function(object, state, timeframe) {\n    // Пока зажата стрелка вверх, маг сначала поднимается, а потом левитирует\n    // в воздухе на определенной высоте.\n    // NB! Сложность заключается в том, что поведение описано в координатах\n    // канваса, а не координатах, относительно нижней границы игры.\n    if (state.keysPressed.UP && object.y > 0) {\n      object.direction = object.direction & ~Direction.DOWN;\n      object.direction = object.direction | Direction.UP;\n      object.y -= object.speed * timeframe * 2;\n    }\n\n    // Если стрелка вверх не зажата, а маг находится в воздухе, он плавно\n    // опускается на землю.\n    if (!state.keysPressed.UP) {\n      if (object.y < HEIGHT - object.height) {\n        object.direction = object.direction & ~Direction.UP;\n        object.direction = object.direction | Direction.DOWN;\n        object.y += object.speed * timeframe / 3;\n      }\n    }\n\n    // Если зажата стрелка влево, маг перемещается влево.\n    if (state.keysPressed.LEFT) {\n      object.direction = object.direction & ~Direction.RIGHT;\n      object.direction = object.direction | Direction.LEFT;\n      object.x -= object.speed * timeframe;\n    }\n\n    // Если зажата стрелка вправо, маг перемещается вправо.\n    if (state.keysPressed.RIGHT) {\n      object.direction = object.direction & ~Direction.LEFT;\n      object.direction = object.direction | Direction.RIGHT;\n      object.x += object.speed * timeframe;\n    }\n\n    // Ограничения по перемещению по полю. Маг не может выйти за пределы поля.\n    if (object.y < 0) {\n      object.y = 0;\n    }\n\n    if (object.y > HEIGHT - object.height) {\n      object.y = HEIGHT - object.height;\n    }\n\n    if (object.x < 0) {\n      object.x = 0;\n    }\n\n    if (object.x > WIDTH - object.width) {\n      object.x = WIDTH - object.width;\n    }\n  };\n\n  /**\n   * Обновление движения файрбола. Файрбол выпускается в определенном направлении\n   * и после этого неуправляемо движется по прямой в заданном направлении. Если\n   * он пролетает весь экран насквозь, он исчезает.\n   * @param {Object} object\n   * @param {Object} _state\n   * @param {number} timeframe\n   */\n  ObjectsBehaviour[ObjectType.FIREBALL] = function(object, _state, timeframe) {\n    if (object.direction & Direction.LEFT) {\n      object.x -= object.speed * timeframe;\n    }\n\n    if (object.direction & Direction.RIGHT) {\n      object.x += object.speed * timeframe;\n    }\n\n    if (object.x < 0 || object.x > WIDTH) {\n      object.state = ObjectState.DISPOSED;\n    }\n  };\n\n  /**\n   * ID возможных ответов функций, проверяющих успех прохождения уровня.\n   * CONTINUE говорит о том, что раунд не закончен и игру нужно продолжать,\n   * WIN о том, что раунд выигран, FAIL — о поражении. PAUSE о том, что игру\n   * нужно прервать.\n   * @enum {number}\n   */\n  var Verdict = {\n    CONTINUE: 0,\n    WIN: 1,\n    FAIL: 2,\n    PAUSE: 3,\n    INTRO: 4\n  };\n\n  /**\n   * Правила завершения уровня. Ключами служат ID уровней, значениями функции\n   * принимающие на вход состояние уровня и возвращающие true, если раунд\n   * можно завершать или false если нет.\n   * @type {Object.<Level, function(Object):boolean>}\n   */\n  var LevelsRules = {};\n\n  /**\n   * Уровень считается пройденным, если был выпущен файлболл и он улетел\n   * за экран.\n   * @param {Object} state\n   * @return {Verdict}\n   */\n  LevelsRules[Level.INTRO] = function(state) {\n    var fireballs = state.garbage.filter(function(object) {\n      return object.type === ObjectType.FIREBALL;\n    });\n\n    return fireballs.length ? Verdict.WIN : Verdict.CONTINUE;\n  };\n\n  /**\n   * Начальные условия для уровней.\n   * @enum {Object.<Level, function>}\n   */\n  var LevelsInitialize = {};\n\n  /**\n   * Первый уровень.\n   * @param {Object} state\n   * @return {Object}\n   */\n  LevelsInitialize[Level.INTRO] = function(state) {\n    state.objects.push(\n      // Установка персонажа в начальное положение. Он стоит в крайнем левом\n      // углу экрана, глядя вправо. Скорость перемещения персонажа на этом\n      // уровне равна 2px за кадр.\n      {\n        direction: Direction.RIGHT,\n        height: 84,\n        speed: 2,\n        sprite: SpriteMap[ObjectType.ME],\n        state: ObjectState.OK,\n        type: ObjectType.ME,\n        width: 61,\n        x: WIDTH / 3,\n        y: HEIGHT - 100\n      }\n    );\n\n    return state;\n  };\n\n  /**\n   * Конструктор объекта Game. Создает canvas, добавляет обработчики событий\n   * и показывает приветственный экран.\n   * @param {Element} container\n   * @constructor\n   */\n  var Game = function(container) {\n    this.container = container;\n    this.canvas = document.createElement('canvas');\n    this.canvas.width = container.clientWidth;\n    this.canvas.height = container.clientHeight;\n    this.container.appendChild(this.canvas);\n\n    this.ctx = this.canvas.getContext('2d');\n\n    this._onKeyDown = this._onKeyDown.bind(this);\n    this._onKeyUp = this._onKeyUp.bind(this);\n    this._pauseListener = this._pauseListener.bind(this);\n\n    this.setDeactivated(false);\n  };\n\n  Game.prototype = {\n    /**\n     * Текущий уровень игры.\n     * @type {Level}\n     */\n    level: INITIAL_LEVEL,\n\n    /** @param {boolean} deactivated */\n    setDeactivated: function(deactivated) {\n      if (this._deactivated === deactivated) {\n        return;\n      }\n\n      this._deactivated = deactivated;\n\n      if (deactivated) {\n        this._removeGameListeners();\n      } else {\n        this._initializeGameListeners();\n      }\n    },\n\n    /**\n     * Состояние игры. Описывает местоположение всех объектов на игровой карте\n     * и время проведенное на уровне и в игре.\n     * @return {Object}\n     */\n    getInitialState: function() {\n      return {\n        // Статус игры. Если CONTINUE, то игра продолжается.\n        currentStatus: Verdict.CONTINUE,\n\n        // Объекты, удаленные на последнем кадре.\n        garbage: [],\n\n        // Время с момента отрисовки предыдущего кадра.\n        lastUpdated: null,\n\n        // Состояние нажатых клавиш.\n        keysPressed: {\n          ESC: false,\n          LEFT: false,\n          RIGHT: false,\n          SPACE: false,\n          UP: false\n        },\n\n        // Время начала прохождения уровня.\n        levelStartTime: null,\n\n        // Все объекты на карте.\n        objects: [],\n\n        // Время начала прохождения игры.\n        startTime: null\n      };\n    },\n\n    /**\n     * Начальные проверки и запуск текущего уровня.\n     * @param {boolean=} restart\n     */\n    initializeLevelAndStart: function(restart) {\n      restart = typeof restart === 'undefined' ? true : restart;\n\n      if (restart || !this.state) {\n        // При перезапуске уровня, происходит полная перезапись состояния\n        // игры из изначального состояния.\n        this.state = this.getInitialState();\n        this.state = LevelsInitialize[this.level](this.state);\n      } else {\n        // При продолжении уровня состояние сохраняется, кроме записи о том,\n        // что состояние уровня изменилось с паузы на продолжение игры.\n        this.state.currentStatus = Verdict.CONTINUE;\n      }\n\n      // Запись времени начала игры и времени начала уровня.\n      this.state.levelStartTime = Date.now();\n      if (!this.state.startTime) {\n        this.state.startTime = this.state.levelStartTime;\n      }\n\n      this._preloadImagesForLevel(function() {\n        // Предварительная отрисовка игрового экрана.\n        this.render();\n\n        // Установка обработчиков событий.\n        this._initializeGameListeners();\n\n        // Запуск игрового цикла.\n        this.update();\n      }.bind(this));\n    },\n\n    /**\n     * Временная остановка игры.\n     * @param {Verdict=} verdict\n     */\n    pauseLevel: function(verdict) {\n      if (verdict) {\n        this.state.currentStatus = verdict;\n      }\n\n      this.state.keysPressed.ESC = false;\n      this.state.lastUpdated = null;\n\n      this._removeGameListeners();\n      window.addEventListener('keydown', this._pauseListener);\n\n      this._drawPauseScreen();\n    },\n\n    /**\n     * Обработчик событий клавиатуры во время паузы.\n     * @param {KeyboardsEvent} evt\n     * @private\n     * @private\n     */\n    _pauseListener: function(evt) {\n      if (evt.keyCode === 32 && !this._deactivated) {\n        evt.preventDefault();\n        var needToRestartTheGame = this.state.currentStatus === Verdict.WIN ||\n            this.state.currentStatus === Verdict.FAIL;\n        this.initializeLevelAndStart(needToRestartTheGame);\n\n        window.removeEventListener('keydown', this._pauseListener);\n      }\n    },\n\n    /**\n     * Выводит текст\n     * @param {String} message\n     * @param {Object} rectanglePosition\n     * @private\n     */\n    _drawRectangleText: function(message, rectanglePosition) {\n      var ctx = this.ctx;\n      var rectangleWidth = rectanglePosition.x3 - rectanglePosition.x2;\n      var str = message;\n      var lineHeight = 22;\n      var positionYStart = 75;\n      var strLimit = rectangleWidth >= 380 ? 33 : Math.floor(rectangleWidth / 11.2);\n      var counter = Math.ceil(str.length / 25);\n      var caretStart = 0;\n      var caretEnd = null;\n      var currentStr = '';\n\n      ctx.font = '16px PT Mono';\n      ctx.textBaseline = 'hanging';\n      ctx.fillStyle = 'black';\n\n      for (var i = 0; i < counter; i++) {\n        caretEnd = str.length - caretStart <= strLimit ? str.length : strLimit;\n        currentStr = str.slice(caretStart, caretEnd);\n\n        caretStart = 0;\n        caretEnd = caretEnd === str.length ? caretEnd : currentStr.lastIndexOf(' ');\n        currentStr = currentStr.slice(caretStart, caretEnd);\n        ctx.fillText(currentStr, rectanglePosition.x2 + 15, positionYStart);\n\n        positionYStart += lineHeight;\n        str = str.slice(caretEnd + 1, str.length);\n      }\n\n      rectanglePosition.y1 = positionYStart + 40;\n      rectanglePosition.y4 = positionYStart + 30;\n\n      ctx.globalCompositeOperation = 'destination-over';\n      this._drawRectangle(rectanglePosition);\n      this._drawRectangleShadow(rectanglePosition);\n    },\n\n    /**\n     * Выводит тень прямоугольника относительно координат прямоугольника\n     * @param {Object} rectanglePosition\n     * @private\n     */\n    _drawRectangleShadow: function(rectanglePosition) {\n      var ctx = this.ctx;\n      var shadowPosition = {};\n\n      for (var key in rectanglePosition) {\n        if ({}.hasOwnProperty.call(rectanglePosition, key)) {\n          shadowPosition[key] = rectanglePosition[key] + 10;\n        }\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(shadowPosition.x1, shadowPosition.y1);\n      ctx.lineTo(shadowPosition.x2, shadowPosition.y2);\n      ctx.lineTo(shadowPosition.x3, shadowPosition.y3);\n      ctx.lineTo(shadowPosition.x4, shadowPosition.y4);\n      ctx.closePath();\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n      ctx.fill();\n    },\n\n    /**\n     * Выводит прямоугольник относительно полученных координат\n     * @param {Object} rectanglePosition\n     * @private\n     */\n    _drawRectangle: function(rectanglePosition) {\n      var ctx = this.ctx;\n\n      ctx.beginPath();\n      ctx.moveTo(rectanglePosition.x1, rectanglePosition.y1);\n      ctx.lineTo(rectanglePosition.x2, rectanglePosition.y2);\n      ctx.lineTo(rectanglePosition.x3, rectanglePosition.y3);\n      ctx.lineTo(rectanglePosition.x4, rectanglePosition.y4);\n      ctx.closePath();\n      ctx.fillStyle = '#FFFFFF';\n      ctx.fill();\n    },\n\n    /**\n     * Считает координаты\n     * @param {Number} positionX\n     * @param {Number} positionY\n     * @returns {Object}\n     */\n    getPosition: function(positionX, positionY) {\n      var x = positionX || 300;\n      var y = positionY || 230;\n      return {\n        x1: x,\n        y1: y,\n        x2: x + 20,\n        y2: y - 180,\n        x3: x + 300,\n        y3: y - 180,\n        x4: x + 300,\n        y4: y - 20\n      };\n    },\n\n    /**\n     * Отрисовка экрана паузы.\n     */\n    _drawPauseScreen: function() {\n      switch (this.state.currentStatus) {\n        case Verdict.WIN:\n          this._drawRectangleText('Поздравляем! Вы победили!', this.getPosition());\n          break;\n        case Verdict.FAIL:\n          this._drawRectangleText('Вы проиграли. Попробуйте еще', this.getPosition());\n          break;\n        case Verdict.PAUSE:\n          this._drawRectangleText('Игра на паузе', this.getPosition());\n          break;\n        case Verdict.INTRO:\n          this._drawRectangleText('Добро пожаловать в «Код и магию»! Нажмите пробел для старта', this.getPosition());\n          break;\n      }\n    },\n\n    /**\n     * Предзагрузка необходимых изображений для уровня.\n     * @param {function} callback\n     * @private\n     */\n    _preloadImagesForLevel: function(callback) {\n      if (typeof this._imagesArePreloaded === 'undefined') {\n        this._imagesArePreloaded = [];\n      }\n\n      if (this._imagesArePreloaded[this.level]) {\n        callback();\n        return;\n      }\n\n      var keys = Object.keys(SpriteMap);\n      var imagesToGo = keys.length;\n\n      var self = this;\n\n      var loadSprite = function(sprite) {\n        var image = new Image(sprite.width, sprite.height);\n        image.onload = function() {\n          sprite.image = image;\n          if (--imagesToGo === 0) {\n            self._imagesArePreloaded[self.level] = true;\n            callback();\n          }\n        };\n        image.src = sprite.url;\n      };\n\n      for (var i = 0; i < keys.length; i++) {\n        loadSprite(SpriteMap[keys[i]]);\n      }\n    },\n\n    /**\n     * Обновление статуса объектов на экране. Добавляет объекты, которые должны\n     * появиться, выполняет проверку поведения всех объектов и удаляет те, которые\n     * должны исчезнуть.\n     * @param {number} delta Время, прошеднее с отрисовки прошлого кадра.\n     */\n    updateObjects: function(delta) {\n      // Персонаж.\n      var me = this.state.objects.filter(function(object) {\n        return object.type === ObjectType.ME;\n      })[0];\n\n      // Добавляет на карту файрбол по нажатию на Shift.\n      if (this.state.keysPressed.SHIFT) {\n        this.state.objects.push({\n          direction: me.direction,\n          height: 24,\n          speed: 5,\n          sprite: SpriteMap[ObjectType.FIREBALL],\n          type: ObjectType.FIREBALL,\n          width: 24,\n          x: me.direction & Direction.RIGHT ? me.x + me.width : me.x - 24,\n          y: me.y + me.height / 2\n        });\n\n        this.state.keysPressed.SHIFT = false;\n      }\n\n      this.state.garbage = [];\n\n      // Убирает в garbage не используемые на карте объекты.\n      var remainingObjects = this.state.objects.filter(function(object) {\n        ObjectsBehaviour[object.type](object, this.state, delta);\n\n        if (object.state === ObjectState.DISPOSED) {\n          this.state.garbage.push(object);\n          return false;\n        }\n\n        return true;\n      }, this);\n\n      this.state.objects = remainingObjects;\n    },\n\n    /**\n     * Проверка статуса текущего уровня.\n     */\n    checkStatus: function() {\n      // Нет нужны запускать проверку, нужно ли останавливать уровень, если\n      // заранее известно, что да.\n      if (this.state.currentStatus !== Verdict.CONTINUE) {\n        return;\n      }\n\n      if (!this.commonRules) {\n        /**\n         * Проверки, не зависящие от уровня, но влияющие на его состояние.\n         * @type {Array.<functions(Object):Verdict>}\n         */\n        this.commonRules = [\n          /**\n           * Если персонаж мертв, игра прекращается.\n           * @param {Object} state\n           * @return {Verdict}\n           */\n          function(state) {\n            var me = state.objects.filter(function(object) {\n              return object.type === ObjectType.ME;\n            })[0];\n\n            return me.state === ObjectState.DISPOSED ?\n                Verdict.FAIL :\n                Verdict.CONTINUE;\n          },\n\n          /**\n           * Если нажата клавиша Esc игра ставится на паузу.\n           * @param {Object} state\n           * @return {Verdict}\n           */\n          function(state) {\n            return state.keysPressed.ESC ? Verdict.PAUSE : Verdict.CONTINUE;\n          },\n\n          /**\n           * Игра прекращается если игрок продолжает играть в нее два часа подряд.\n           * @param {Object} state\n           * @return {Verdict}\n           */\n          function(state) {\n            return Date.now() - state.startTime > 3 * 60 * 1000 ?\n                Verdict.FAIL :\n                Verdict.CONTINUE;\n          }\n        ];\n      }\n\n      // Проверка всех правил влияющих на уровень. Запускаем цикл проверок\n      // по всем универсальным проверкам и проверкам конкретного уровня.\n      // Цикл продолжается до тех пор, пока какая-либо из проверок не вернет\n      // любое другое состояние кроме CONTINUE или пока не пройдут все\n      // проверки. После этого состояние сохраняется.\n      var allChecks = this.commonRules.concat(LevelsRules[this.level]);\n      var currentCheck = Verdict.CONTINUE;\n      var currentRule;\n\n      while (currentCheck === Verdict.CONTINUE && allChecks.length) {\n        currentRule = allChecks.shift();\n        currentCheck = currentRule(this.state);\n      }\n\n      this.state.currentStatus = currentCheck;\n    },\n\n    /**\n     * Принудительная установка состояния игры. Используется для изменения\n     * состояния игры от внешних условий, например, когда необходимо остановить\n     * игру, если она находится вне области видимости и установить вводный\n     * экран.\n     * @param {Verdict} status\n     */\n    setGameStatus: function(status) {\n      if (this.state.currentStatus !== status) {\n        this.state.currentStatus = status;\n      }\n    },\n\n    /**\n     * Отрисовка всех объектов на экране.\n     */\n    render: function() {\n      // Удаление всех отрисованных на странице элементов.\n      this.ctx.clearRect(0, 0, WIDTH, HEIGHT);\n\n      // Выставление всех элементов, оставшихся в this.state.objects согласно\n      // их координатам и направлению.\n      this.state.objects.forEach(function(object) {\n        if (object.sprite) {\n          var reversed = object.direction & Direction.LEFT;\n          var sprite = SpriteMap[object.type + (reversed ? REVERSED : '')] || SpriteMap[object.type];\n          this.ctx.drawImage(sprite.image, object.x, object.y, object.width, object.height);\n        }\n      }, this);\n    },\n\n    /**\n     * Основной игровой цикл. Сначала проверяет состояние всех объектов игры\n     * и обновляет их согласно правилам их поведения, а затем запускает\n     * проверку текущего раунда. Рекурсивно продолжается до тех пор, пока\n     * проверка не вернет состояние FAIL, WIN или PAUSE.\n     */\n    update: function() {\n      if (!this.state.lastUpdated) {\n        this.state.lastUpdated = Date.now();\n      }\n\n      var delta = (Date.now() - this.state.lastUpdated) / 10;\n      this.updateObjects(delta);\n      this.checkStatus();\n\n      switch (this.state.currentStatus) {\n        case Verdict.CONTINUE:\n          this.state.lastUpdated = Date.now();\n          this.render();\n          requestAnimationFrame(function() {\n            this.update();\n          }.bind(this));\n          break;\n\n        case Verdict.WIN:\n        case Verdict.FAIL:\n        case Verdict.PAUSE:\n        case Verdict.INTRO:\n          this.pauseLevel();\n          break;\n      }\n    },\n\n    /**\n     * @param {KeyboardEvent} evt [description]\n     * @private\n     */\n    _onKeyDown: function(evt) {\n      switch (evt.keyCode) {\n        case 37:\n          this.state.keysPressed.LEFT = true;\n          break;\n        case 39:\n          this.state.keysPressed.RIGHT = true;\n          break;\n        case 38:\n          this.state.keysPressed.UP = true;\n          break;\n        case 27:\n          this.state.keysPressed.ESC = true;\n          break;\n      }\n\n      if (evt.shiftKey) {\n        this.state.keysPressed.SHIFT = true;\n      }\n    },\n\n    /**\n     * @param {KeyboardEvent} evt [description]\n     * @private\n     */\n    _onKeyUp: function(evt) {\n      switch (evt.keyCode) {\n        case 37:\n          this.state.keysPressed.LEFT = false;\n          break;\n        case 39:\n          this.state.keysPressed.RIGHT = false;\n          break;\n        case 38:\n          this.state.keysPressed.UP = false;\n          break;\n        case 27:\n          this.state.keysPressed.ESC = false;\n          break;\n      }\n\n      if (evt.shiftKey) {\n        this.state.keysPressed.SHIFT = false;\n      }\n    },\n\n    /** @private */\n    _initializeGameListeners: function() {\n      window.addEventListener('keydown', this._onKeyDown);\n      window.addEventListener('keyup', this._onKeyUp);\n    },\n\n    /** @private */\n    _removeGameListeners: function() {\n      window.removeEventListener('keydown', this._onKeyDown);\n      window.removeEventListener('keyup', this._onKeyUp);\n    }\n  };\n\n  Game.Verdict = Verdict;\n\n  return Game;\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/game.js\n ** module id = 0\n ** module chunks = 2\n **/"],"sourceRoot":""}